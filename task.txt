1. Основная логика OVAL заключается в том, что в одном XML файле описаны уязвимости, методы определения, ссылки на патчи, ссылки на CVE и т.д.
Файлы OVAL позволяют автоматизировать процесс анализа безопасности. 
В файле есть блок definitions, который содержит в себе блоки definition - определения уязвимостей. 
В каждом блоке definition имеютя метаданные (definitions->definition->metadata ) и критерии (definitions->definition->criteria) 
В блоке критериев с помощью логических выражений описаны условия, при которых система считается уязвимой
Блок metadata содержит основную информацию - заголовок (..definition->title), семейство ОС (affected.family), платформу, ссылки на различные источники (reference), описание уязвимости (description), номер CVE и рейтинг CVSS и т.д.
В каждом теге definition также хранится информация об id, класс дефинишена в нашем случае патчи class='patch'
Каждая уязвимость описывается в отдельном definition, и информация о ней может быть извлечена с помощью XML-парсера

2. Важные элементы в файле включают в себя:
definition - определение уязвимости или патча. Содержит информацию о CVE, описании, инструкциях по устранению и другие метаданные
metadata - метаданные определения, такие как заголовок и описание
reference - cсылки на различные источники, включая CVE
tests - описание проверок проверки
objects - объекты проверок
criteria - условия, при которых система считается уязвимой
states  - описание формальных условий теста, применимых к объектам

3. При анализе OVAL-файла rhel-8 критерии из разряда "Red Hat Enterprise Linux must be installed" и "Red Hat Enterprise Linux 8 is installed" кажутся лишними. 
Понимаю, что они необходимы для чтения программной, но при ручном анализе сильно отвлекают

4. Сложный вопрос, у меня нет вопросов по поводу описания уязвимостии и проверок, они читабельны и удобны. Могу лишь высказаться по поводу критериев. 
На мой взгляд формат "обертывания" комментариев в блоки операторов очень громоздкий, множество критериев дублируют друг друга, возможно ли упростить эти выражения? 
Однако другого более удобного способа предложить не могу

5. Реализация парсера в файле main.py
